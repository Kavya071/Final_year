const express = require('express');
const cors = require('cors');
const { MongoClient } = require('mongodb');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// MongoDB connection
const MONGO_URI = "mongodb+srv://bhardwajkavya099_db_user:Gfq88i5GvO3WzcRG@cluster0.jx5vysg.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";
const DB_NAME = 'prepai_db';
const COLLECTION_NAME = 'dsa_problems';

let db = null;
let leetcodeProblems = [];

// LeetCode API Client
class LeetCodeAPIClient {
    constructor() {
        this.baseUrl = 'https://leetcode.com/graphql';
        this.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Content-Type': 'application/json',
            'Referer': 'https://leetcode.com'
        };
    }

    async getAllProblems() {
        const query = `
        query {
            problemsetQuestionList: questionList(
                categorySlug: ""
                limit: 1000
                skip: 0
                filters: {}
            ) {
                total: totalNum
                questions: data {
                    acRate
                    difficulty
                    freqBar
                    frontendQuestionId: questionFrontendId
                    isFavor
                    paidOnly: isPaidOnly
                    status
                    title
                    titleSlug
                    topicTags {
                        name
                        id
                        slug
                    }
                }
            }
        }`;

        try {
            const response = await axios.post(this.baseUrl, {
                query: query
            }, { headers: this.headers });

            if (response.data && response.data.data) {
                return response.data.data.problemsetQuestionList.questions.filter(p => !p.paidOnly);
            }
            return [];
        } catch (error) {
            console.error('Error fetching LeetCode problems:', error);
            return [];
        }
    }

    async getProblemDetails(titleSlug) {
        const query = `
        query {
            question(titleSlug: "${titleSlug}") {
                questionId
                questionFrontendId
                title
                titleSlug
                content
                difficulty
                likes
                dislikes
                isLiked
                similarQuestions
                topicTags {
                    name
                    slug
                }
                stats
            }
        }`;

        try {
            const response = await axios.post(this.baseUrl, {
                query: query
            }, { headers: this.headers });

            if (response.data && response.data.data) {
                return response.data.data.question;
            }
            return null;
        } catch (error) {
            console.error('Error fetching problem details:', error);
            return null;
        }
    }
}

// AI MCQ Generator
class AIMCQGenerator {
    constructor() {
        this.usedQuestions = new Set();
    }

    generateContextualMCQ(problem) {
        const title = problem.title || 'LeetCode Problem';
        const difficulty = problem.difficulty || 'Medium';
        const tags = problem.topicTags || [];
        
        const questionTypes = [
            'algorithm_choice',
            'data_structure',
            'time_complexity',
            'approach_analysis',
            'optimization',
            'pattern_recognition'
        ];
        
        const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
        
        let question = '';
        let options = [];
        let correctAnswer = '';
        let explanation = '';
        
        const titleLower = title.toLowerCase();
        const hasTree = tags.some(tag => tag.name && tag.name.toLowerCase().includes('tree')) || titleLower.includes('tree');
        const hasGraph = tags.some(tag => tag.name && tag.name.toLowerCase().includes('graph')) || titleLower.includes('graph');
        const hasArray = tags.some(tag => tag.name && tag.name.toLowerCase().includes('array')) || titleLower.includes('array');
        const hasString = tags.some(tag => tag.name && tag.name.toLowerCase().includes('string')) || titleLower.includes('string');
        const hasDP = tags.some(tag => tag.name && tag.name.toLowerCase().includes('dynamic')) || titleLower.includes('dynamic');
        const hasSort = titleLower.includes('sort') || tags.some(tag => tag.name && tag.name.toLowerCase().includes('sort'));
        
        switch (questionType) {
            case 'algorithm_choice':
                if (hasTree) {
                    question = `For LeetCode problem "${title}", which traversal approach is most suitable?`;
                    options = ['Depth-First Search (DFS)', 'Breadth-First Search (BFS)', 'In-order Traversal', 'Pre-order Traversal'];
                    correctAnswer = 'Depth-First Search (DFS)';
                    explanation = `Tree problems like "${title}" typically benefit from DFS for recursive solutions.`;
                } else if (hasGraph) {
                    question = `What graph algorithm is optimal for "${title}"?`;
                    options = ['Dijkstra Algorithm', 'Breadth-First Search', 'Depth-First Search', 'Floyd-Warshall'];
                    correctAnswer = 'Breadth-First Search';
                    explanation = `Graph problems like "${title}" often use BFS for shortest path solutions.`;
                } else if (hasDP) {
                    question = `What dynamic programming approach works best for "${title}"?`;
                    options = ['Top-down Memoization', 'Bottom-up Tabulation', 'Space Optimization', 'State Compression'];
                    correctAnswer = 'Top-down Memoization';
                    explanation = `DP problems like "${title}" often start with recursive solutions optimized with memoization.`;
                } else {
                    question = `What algorithmic approach is most effective for "${title}"?`;
                    options = ['Two Pointers', 'Sliding Window', 'Binary Search', 'Greedy Algorithm'];
                    correctAnswer = 'Two Pointers';
                    explanation = `"${title}" can be efficiently solved using two pointers technique.`;
                }
                break;
                
            case 'time_complexity':
                if (difficulty === 'Easy') {
                    question = `What is the optimal time complexity for "${title}"?`;
                    options = ['O(n)', 'O(log n)', 'O(1)', 'O(n log n)'];
                    correctAnswer = 'O(n)';
                    explanation = `Easy problems like "${title}" typically have linear time solutions.`;
                } else if (difficulty === 'Medium') {
                    question = `What time complexity should you target for "${title}"?`;
                    options = ['O(n log n)', 'O(n²)', 'O(n)', 'O(log n)'];
                    correctAnswer = 'O(n log n)';
                    explanation = `Medium problems like "${title}" often require O(n log n) complexity.`;
                } else {
                    question = `What is the expected time complexity for "${title}"?`;
                    options = ['O(n²)', 'O(n³)', 'O(2^n)', 'O(n log n)'];
                    correctAnswer = 'O(n²)';
                    explanation = `Hard problems like "${title}" may require quadratic time complexity.`;
                }
                break;
                
            case 'data_structure':
                if (hasArray) {
                    question = `Which data structure optimizes "${title}"?`;
                    options = ['Hash Map', 'Priority Queue', 'Stack', 'Deque'];
                    correctAnswer = 'Hash Map';
                    explanation = `Array problems like "${title}" benefit from Hash Map's O(1) lookup.`;
                } else if (hasString) {
                    question = `What data structure is most suitable for "${title}"?`;
                    options = ['Trie', 'Hash Set', 'StringBuilder', 'Character Array'];
                    correctAnswer = 'Trie';
                    explanation = `String problems like "${title}" often use Trie for efficient prefix operations.`;
                } else {
                    question = `Which data structure best supports "${title}"?`;
                    options = ['Stack', 'Queue', 'Heap', 'Set'];
                    correctAnswer = 'Stack';
                    explanation = `"${title}" can be solved efficiently using Stack data structure.`;
                }
                break;
                
            default:
                question = `What is the key insight for solving "${title}"?`;
                options = ['Pattern Recognition', 'Edge Case Handling', 'Optimization Strategy', 'Algorithm Selection'];
                correctAnswer = 'Pattern Recognition';
                explanation = `Solving "${title}" requires recognizing the underlying algorithmic pattern.`;
        }
        
        // Shuffle options
        const shuffled = this.shuffleOptions(options, options.indexOf(correctAnswer));
        
        return {
            question: question,
            options: shuffled.options,
            correctAnswer: shuffled.correctAnswer,
            explanation: explanation,
            metadata: {
                difficulty: difficulty,
                problemTitle: title,
                source: 'LeetCode',
                tags: tags.map(tag => tag.name || tag),
                generatedBy: 'LeetCode AI MCQ Generator v1.0',
                questionType: questionType,
                generatedAt: new Date().toISOString()
            }
        };
    }
    
    shuffleOptions(options, correctIndex) {
        const shuffled = [...options];
        const correctAnswer = shuffled[correctIndex];
        
        // Fisher-Yates shuffle
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        
        return {
            options: shuffled,
            correctAnswer: correctAnswer
        };
    }
}

const leetcodeClient = new LeetCodeAPIClient();
const mcqGenerator = new AIMCQGenerator();

// Connect to MongoDB
async function connectToMongoDB() {
    try {
        const client = new MongoClient(MONGO_URI, {
            tls: true,
            tlsAllowInvalidCertificates: true
        });
        await client.connect();
        db = client.db(DB_NAME);
        console.log('✅ Connected to MongoDB Atlas');
    } catch (error) {
        console.error('❌ Failed to connect to MongoDB:', error);
        process.exit(1);
    }
}

// API Routes

// Health check
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        message: 'PrepAI Backend API is running',
        timestamp: new Date().toISOString()
    });
});

// Get all problems
app.get('/api/problems', async (req, res) => {
    try {
        const collection = db.collection(COLLECTION_NAME);
        const problems = await collection.find({}).limit(100).toArray();
        
        res.json({
            success: true,
            count: problems.length,
            data: problems
        });
    } catch (error) {
        console.error('Error fetching problems:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch problems',
            error: error.message
        });
    }
});

// Get problems by difficulty
app.get('/api/problems/difficulty/:level', async (req, res) => {
    try {
        const { level } = req.params;
        const validLevels = ['Easy', 'Medium', 'Hard', 'Expert'];
        
        if (!validLevels.includes(level)) {
            return res.status(400).json({
                success: false,
                message: 'Invalid difficulty level. Use: Easy, Medium, Hard, or Expert'
            });
        }

        const collection = db.collection(COLLECTION_NAME);
        const problems = await collection.find({ 
            difficulty_category: level 
        }).limit(50).toArray();
        
        res.json({
            success: true,
            difficulty: level,
            count: problems.length,
            data: problems
        });
    } catch (error) {
        console.error('Error fetching problems by difficulty:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch problems by difficulty',
            error: error.message
        });
    }
});

// Get random problem
app.get('/api/problems/random', async (req, res) => {
    try {
        const { difficulty } = req.query;
        const collection = db.collection(COLLECTION_NAME);
        
        let matchStage = {};
        if (difficulty && ['Easy', 'Medium', 'Hard', 'Expert'].includes(difficulty)) {
            matchStage = { difficulty_category: difficulty };
        }

        const pipeline = [
            { $match: matchStage },
            { $sample: { size: 1 } }
        ];

        const problems = await collection.aggregate(pipeline).toArray();
        
        if (problems.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'No problems found'
            });
        }

        res.json({
            success: true,
            data: problems[0]
        });
    } catch (error) {
        console.error('Error fetching random problem:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch random problem',
            error: error.message
        });
    }
});

// Get problem by ID
app.get('/api/problems/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const collection = db.collection(COLLECTION_NAME);
        
        const problem = await collection.findOne({ 
            problem_id: parseInt(id) 
        });
        
        if (!problem) {
            return res.status(404).json({
                success: false,
                message: 'Problem not found'
            });
        }

        res.json({
            success: true,
            data: problem
        });
    } catch (error) {
        console.error('Error fetching problem by ID:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch problem',
            error: error.message
        });
    }
});

// Get statistics
app.get('/api/stats', async (req, res) => {
    try {
        const collection = db.collection(COLLECTION_NAME);
        
        const totalProblems = await collection.countDocuments();
        const easyCount = await collection.countDocuments({ difficulty_category: 'Easy' });
        const mediumCount = await collection.countDocuments({ difficulty_category: 'Medium' });
        const hardCount = await collection.countDocuments({ difficulty_category: 'Hard' });
        const expertCount = await collection.countDocuments({ difficulty_category: 'Expert' });
        
        res.json({
            success: true,
            data: {
                total: totalProblems,
                difficulty_distribution: {
                    Easy: easyCount,
                    Medium: mediumCount,
                    Hard: hardCount,
                    Expert: expertCount
                }
            }
        });
    } catch (error) {
        console.error('Error fetching statistics:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch statistics',
            error: error.message
        });
    }
});

// Start server
async function startServer() {
    await connectToMongoDB();
    
    app.listen(PORT, () => {
        console.log(`🚀 PrepAI Backend API running on http://localhost:${PORT}`);
        console.log(`📊 API Documentation:`);
        console.log(`   GET /api/health - Health check`);
        console.log(`   GET /api/problems - Get all problems`);
        console.log(`   GET /api/problems/difficulty/:level - Get problems by difficulty`);
        console.log(`   GET /api/problems/random?difficulty=Easy - Get random problem`);
        console.log(`   GET /api/problems/:id - Get problem by ID`);
        console.log(`   GET /api/stats - Get database statistics`);
    });
}

startServer().catch(console.error);